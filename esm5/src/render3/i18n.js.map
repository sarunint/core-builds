{"version":3,"file":"i18n.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/i18n.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NO_CHANGE} from '../../src/render3/tokens';\n\nimport {assertEqual, assertLessThan} from './assert';\nimport {adjustBlueprintForNewNode, bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4, createNodeAtIndex, load} from './instructions';\nimport {LContainer, NATIVE, RENDER_PARENT} from './interfaces/container';\nimport {TElementNode, TNode, TNodeType} from './interfaces/node';\nimport {RComment, RElement} from './interfaces/renderer';\nimport {StylingContext} from './interfaces/styling';\nimport {BINDING_INDEX, HEADER_OFFSET, HOST_NODE, TVIEW} from './interfaces/view';\nimport {appendChild, createTextNode, removeChild} from './node_manipulation';\nimport {getRenderer, getViewData, resetComponentState} from './state';\nimport {getNativeByIndex, getNativeByTNode, getTNode, isLContainer, stringify} from './util';\n\n\n\n/**\n * A list of flags to encode the i18n instructions used to translate the template.\n * We shift the flags by 29 so that 30 & 31 & 32 bits contains the instructions.\n */\nexport const enum I18nInstructions {\n  Text = 1 << 29,\n  Element = 2 << 29,\n  Expression = 3 << 29,\n  TemplateRoot = 4 << 29,\n  Any = 5 << 29,\n  CloseNode = 6 << 29,\n  RemoveNode = 7 << 29,\n  /** Used to decode the number encoded with the instruction. */\n  IndexMask = (1 << 29) - 1,\n  /** Used to test the type of instruction. */\n  InstructionMask = ~((1 << 29) - 1),\n}\n\n/**\n * Represents the instructions used to translate the template.\n * Instructions can be a placeholder index, a static text or a simple bit field (`I18nFlag`).\n * When the instruction is the flag `Text`, it is always followed by its text value.\n */\nexport type I18nInstruction = number | string;\n/**\n * Represents the instructions used to translate attributes containing expressions.\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\n * value will be concatenated into the final translation.\n */\nexport type I18nExpInstruction = number | string;\n/** Mapping of placeholder names to their absolute indexes in their templates. */\nexport type PlaceholderMap = {\n  [name: string]: number\n};\nconst i18nTagRegex = /{\\$([^}]+)}/g;\n\n/**\n * Takes a translation string, the initial list of placeholders (elements and expressions) and the\n * indexes of their corresponding expression nodes to return a list of instructions for each\n * template function.\n *\n * Because embedded templates have different indexes for each placeholder, each parameter (except\n * the translation) is an array, where each value corresponds to a different template, by order of\n * appearance.\n *\n * @param translation A translation string where placeholders are represented by `{$name}`\n * @param elements An array containing, for each template, the maps of element placeholders and\n * their indexes.\n * @param expressions An array containing, for each template, the maps of expression placeholders\n * and their indexes.\n * @param templateRoots An array of template roots whose content should be ignored when\n * generating the instructions for their parent template.\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\n * an ng-container.\n *\n * @returns A list of instructions used to translate each template.\n */\nexport function i18nMapping(\n    translation: string, elements: (PlaceholderMap | null)[] | null,\n    expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null,\n    lastChildIndex?: number | null): I18nInstruction[][] {\n  const translationParts = translation.split(i18nTagRegex);\n  const nbTemplates = templateRoots ? templateRoots.length + 1 : 1;\n  const instructions: I18nInstruction[][] = (new Array(nbTemplates)).fill(undefined);\n\n  generateMappingInstructions(\n      0, 0, translationParts, instructions, elements, expressions, templateRoots, lastChildIndex);\n\n  return instructions;\n}\n\n/**\n * Internal function that reads the translation parts and generates a set of instructions for each\n * template.\n *\n * See `i18nMapping()` for more details.\n *\n * @param tmplIndex The order of appearance of the template.\n * 0 for the root template, following indexes match the order in `templateRoots`.\n * @param partIndex The current index in `translationParts`.\n * @param translationParts The translation string split into an array of placeholders and text\n * elements.\n * @param instructions The current list of instructions to update.\n * @param elements An array containing, for each template, the maps of element placeholders and\n * their indexes.\n * @param expressions An array containing, for each template, the maps of expression placeholders\n * and their indexes.\n * @param templateRoots An array of template roots whose content should be ignored when\n * generating the instructions for their parent template.\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\n * an ng-container.\n *\n * @returns the current index in `translationParts`\n */\nfunction generateMappingInstructions(\n    tmplIndex: number, partIndex: number, translationParts: string[],\n    instructions: I18nInstruction[][], elements: (PlaceholderMap | null)[] | null,\n    expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null,\n    lastChildIndex?: number | null): number {\n  const tmplInstructions: I18nInstruction[] = [];\n  const phVisited: string[] = [];\n  let openedTagCount = 0;\n  let maxIndex = 0;\n  let currentElements: PlaceholderMap|null =\n      elements && elements[tmplIndex] ? elements[tmplIndex] : null;\n  let currentExpressions: PlaceholderMap|null =\n      expressions && expressions[tmplIndex] ? expressions[tmplIndex] : null;\n\n  instructions[tmplIndex] = tmplInstructions;\n\n  for (; partIndex < translationParts.length; partIndex++) {\n    // The value can either be text or the name of a placeholder (element/template root/expression)\n    const value = translationParts[partIndex];\n\n    // Odd indexes are placeholders\n    if (partIndex & 1) {\n      let phIndex;\n      if (currentElements && currentElements[value] !== undefined) {\n        phIndex = currentElements[value];\n        // The placeholder represents a DOM element, add an instruction to move it\n        let templateRootIndex = templateRoots ? templateRoots.indexOf(value) : -1;\n        if (templateRootIndex !== -1 && (templateRootIndex + 1) !== tmplIndex) {\n          // This is a template root, it has no closing tag, not treating it as an element\n          tmplInstructions.push(phIndex | I18nInstructions.TemplateRoot);\n        } else {\n          tmplInstructions.push(phIndex | I18nInstructions.Element);\n          openedTagCount++;\n        }\n        phVisited.push(value);\n      } else if (currentExpressions && currentExpressions[value] !== undefined) {\n        phIndex = currentExpressions[value];\n        // The placeholder represents an expression, add an instruction to move it\n        tmplInstructions.push(phIndex | I18nInstructions.Expression);\n        phVisited.push(value);\n      } else {\n        // It is a closing tag\n        tmplInstructions.push(I18nInstructions.CloseNode);\n\n        if (tmplIndex > 0) {\n          openedTagCount--;\n\n          // If we have reached the closing tag for this template, exit the loop\n          if (openedTagCount === 0) {\n            break;\n          }\n        }\n      }\n\n      if (phIndex !== undefined && phIndex > maxIndex) {\n        maxIndex = phIndex;\n      }\n\n      if (templateRoots) {\n        const newTmplIndex = templateRoots.indexOf(value) + 1;\n        if (newTmplIndex !== 0 && newTmplIndex !== tmplIndex) {\n          partIndex = generateMappingInstructions(\n              newTmplIndex, partIndex, translationParts, instructions, elements, expressions,\n              templateRoots, lastChildIndex);\n        }\n      }\n\n    } else if (value) {\n      // It's a non-empty string, create a text node\n      tmplInstructions.push(I18nInstructions.Text, value);\n    }\n  }\n\n  // Add instructions to remove elements that are not used in the translation\n  if (elements) {\n    const tmplElements = elements[tmplIndex];\n\n    if (tmplElements) {\n      const phKeys = Object.keys(tmplElements);\n\n      for (let i = 0; i < phKeys.length; i++) {\n        const ph = phKeys[i];\n\n        if (phVisited.indexOf(ph) === -1) {\n          let index = tmplElements[ph];\n          // Add an instruction to remove the element\n          tmplInstructions.push(index | I18nInstructions.RemoveNode);\n\n          if (index > maxIndex) {\n            maxIndex = index;\n          }\n        }\n      }\n    }\n  }\n\n  // Add instructions to remove expressions that are not used in the translation\n  if (expressions) {\n    const tmplExpressions = expressions[tmplIndex];\n\n    if (tmplExpressions) {\n      const phKeys = Object.keys(tmplExpressions);\n\n      for (let i = 0; i < phKeys.length; i++) {\n        const ph = phKeys[i];\n\n        if (phVisited.indexOf(ph) === -1) {\n          let index = tmplExpressions[ph];\n          if (ngDevMode) {\n            assertLessThan(\n                index.toString(2).length, 28, `Index ${index} is too big and will overflow`);\n          }\n          // Add an instruction to remove the expression\n          tmplInstructions.push(index | I18nInstructions.RemoveNode);\n\n          if (index > maxIndex) {\n            maxIndex = index;\n          }\n        }\n      }\n    }\n  }\n\n  if (tmplIndex === 0 && typeof lastChildIndex === 'number') {\n    // The current parent is an ng-container and it has more children after the translation that we\n    // need to append to keep the order of the DOM nodes correct\n    for (let i = maxIndex + 1; i <= lastChildIndex; i++) {\n      if (ngDevMode) {\n        assertLessThan(i.toString(2).length, 28, `Index ${i} is too big and will overflow`);\n      }\n      tmplInstructions.push(i | I18nInstructions.Any);\n    }\n  }\n\n  return partIndex;\n}\n\nfunction appendI18nNode(tNode: TNode, parentTNode: TNode, previousTNode: TNode): TNode {\n  if (ngDevMode) {\n    ngDevMode.rendererMoveNode++;\n  }\n\n  const viewData = getViewData();\n\n  // On first pass, re-organize node tree to put this node in the correct position.\n  const firstTemplatePass = viewData[TVIEW].firstTemplatePass;\n  if (firstTemplatePass) {\n    if (previousTNode === parentTNode && tNode !== parentTNode.child) {\n      tNode.next = parentTNode.child;\n      parentTNode.child = tNode;\n    } else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {\n      tNode.next = previousTNode.next;\n      previousTNode.next = tNode;\n    } else {\n      tNode.next = null;\n    }\n\n    if (parentTNode !== viewData[HOST_NODE]) {\n      tNode.parent = parentTNode as TElementNode;\n    }\n  }\n\n  appendChild(getNativeByTNode(tNode, viewData), tNode, viewData);\n\n  const slotValue = viewData[tNode.index];\n  if (tNode.type !== TNodeType.Container && isLContainer(slotValue)) {\n    // Nodes that inject ViewContainerRef also have a comment node that should be moved\n    appendChild(slotValue[NATIVE], tNode, viewData);\n  }\n\n  return tNode;\n}\n\nexport function i18nAttribute(index: number, attrs: any[]): void {\n  // placeholder for i18nAttribute function\n}\n\nexport function i18nExp(expression: any): void {\n  // placeholder for i18nExp function\n}\n\nexport function i18nStart(index: number, message: string, subTemplateIndex: number = 0): void {\n  // placeholder for i18nExp function\n}\n\nexport function i18nEnd(): void {\n  // placeholder for i18nEnd function\n}\n\n/**\n * Takes a list of instructions generated by `i18nMapping()` to transform the template accordingly.\n *\n * @param startIndex Index of the first element to translate (for instance the first child of the\n * element with the i18n attribute).\n * @param instructions The list of instructions to apply on the current view.\n */\nexport function i18nApply(startIndex: number, instructions: I18nInstruction[]): void {\n  const viewData = getViewData();\n  if (ngDevMode) {\n    assertEqual(\n        viewData[BINDING_INDEX], viewData[TVIEW].bindingStartIndex,\n        'i18nApply should be called before any binding');\n  }\n\n  if (!instructions) {\n    return;\n  }\n\n  const renderer = getRenderer();\n  const startTNode = getTNode(startIndex, viewData);\n  let localParentTNode: TNode = startTNode.parent || viewData[HOST_NODE] !;\n  let localPreviousTNode: TNode = localParentTNode;\n  resetComponentState();  // We don't want to add to the tree with the wrong previous node\n\n  for (let i = 0; i < instructions.length; i++) {\n    const instruction = instructions[i] as number;\n    switch (instruction & I18nInstructions.InstructionMask) {\n      case I18nInstructions.Element:\n        const elementTNode = getTNode(instruction & I18nInstructions.IndexMask, viewData);\n        localPreviousTNode = appendI18nNode(elementTNode, localParentTNode, localPreviousTNode);\n        localParentTNode = elementTNode;\n        break;\n      case I18nInstructions.Expression:\n      case I18nInstructions.TemplateRoot:\n      case I18nInstructions.Any:\n        const nodeIndex = instruction & I18nInstructions.IndexMask;\n        localPreviousTNode =\n            appendI18nNode(getTNode(nodeIndex, viewData), localParentTNode, localPreviousTNode);\n        break;\n      case I18nInstructions.Text:\n        if (ngDevMode) {\n          ngDevMode.rendererCreateTextNode++;\n        }\n        const value = instructions[++i];\n        const textRNode = createTextNode(value, renderer);\n        // If we were to only create a `RNode` then projections won't move the text.\n        // Create text node at the current end of viewData. Must subtract header offset because\n        // createNodeAtIndex takes a raw index (not adjusted by header offset).\n        adjustBlueprintForNewNode(viewData);\n        const textTNode = createNodeAtIndex(\n            viewData.length - 1 - HEADER_OFFSET, TNodeType.Element, textRNode, null, null);\n        localPreviousTNode = appendI18nNode(textTNode, localParentTNode, localPreviousTNode);\n        resetComponentState();\n        break;\n      case I18nInstructions.CloseNode:\n        localPreviousTNode = localParentTNode;\n        localParentTNode = localParentTNode.parent || viewData[HOST_NODE] !;\n        break;\n      case I18nInstructions.RemoveNode:\n        if (ngDevMode) {\n          ngDevMode.rendererRemoveNode++;\n        }\n        const removeIndex = instruction & I18nInstructions.IndexMask;\n        const removedElement: RElement|RComment = getNativeByIndex(removeIndex, viewData);\n        const removedTNode = getTNode(removeIndex, viewData);\n        removeChild(removedTNode, removedElement || null, viewData);\n\n        const slotValue = load(removeIndex) as RElement | RComment | LContainer | StylingContext;\n        if (isLContainer(slotValue)) {\n          const lContainer = slotValue as LContainer;\n          if (removedTNode.type !== TNodeType.Container) {\n            removeChild(removedTNode, lContainer[NATIVE] || null, viewData);\n          }\n          removedTNode.detached = true;\n          lContainer[RENDER_PARENT] = null;\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Takes a translation string and the initial list of expressions and returns a list of instructions\n * that will be used to translate an attribute.\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\n * value will be concatenated into the final translation.\n */\nexport function i18nExpMapping(\n    translation: string, placeholders: PlaceholderMap): I18nExpInstruction[] {\n  const staticText: I18nExpInstruction[] = translation.split(i18nTagRegex);\n  // odd indexes are placeholders\n  for (let i = 1; i < staticText.length; i += 2) {\n    staticText[i] = placeholders[staticText[i]];\n  }\n  return staticText;\n}\n\n/**\n * Checks if the value of an expression has changed and replaces it by its value in a translation,\n * or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation1(instructions: I18nExpInstruction[], v0: any): string|NO_CHANGE {\n  const different = bindingUpdated(getViewData()[BINDING_INDEX]++, v0);\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      res += stringify(v0);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 2 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation2(instructions: I18nExpInstruction[], v0: any, v1: any): string|\n    NO_CHANGE {\n  const viewData = getViewData();\n  const different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\n  viewData[BINDING_INDEX] += 2;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b1 ? v1 : v0;\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 3 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation3(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any): string|NO_CHANGE {\n  const viewData = getViewData();\n  const different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\n  viewData[BINDING_INDEX] += 3;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b2 ? v2 : (b1 ? v1 : v0);\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 4 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation4(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any): string|NO_CHANGE {\n  const viewData = getViewData();\n  const different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  viewData[BINDING_INDEX] += 4;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0);\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 5 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation5(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any): string|\n    NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\n  viewData[BINDING_INDEX] += 5;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? v4 : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 6 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */ export function\ni18nInterpolation6(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any):\n    string|NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\n  viewData[BINDING_INDEX] += 6;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? (b1 ? v5 : v4) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 7 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n * @param v6 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation7(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any,\n    v6: any): string|NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\n  viewData[BINDING_INDEX] += 7;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? (b2 ? v6 : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 8 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n * @param v6 value checked for change.\n * @param v7 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation8(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any,\n    v6: any, v7: any): string|NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\n  viewData[BINDING_INDEX] += 8;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value =\n          b4 ? (b2 ? (b1 ? v7 : v6) : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Create a translated interpolation binding with a variable number of expressions.\n *\n * If there are 1 to 8 expressions then `i18nInterpolation()` should be used instead. It is faster\n * because there is no need to create an array of expressions and iterate over it.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolationV(instructions: I18nExpInstruction[], values: any[]): string|\n    NO_CHANGE {\n  const viewData = getViewData();\n  let different = false;\n  for (let i = 0; i < values.length; i++) {\n    // Check if bindings have changed\n    bindingUpdated(viewData[BINDING_INDEX]++, values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are placeholders\n    if (i & 1) {\n      res += stringify(values[instructions[i] as number]);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n"]}