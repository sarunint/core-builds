{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {devModeEqual} from '../change_detection/change_detection_util';\nimport {global} from '../util';\n\nimport {assertDefined, assertLessThan} from './assert';\nimport {ACTIVE_INDEX, LContainer} from './interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {ComponentDef, DirectiveDef} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags} from './interfaces/injector';\nimport {TContainerNode, TElementNode, TNode, TNodeFlags} from './interfaces/node';\nimport {RComment, RElement, RText} from './interfaces/renderer';\nimport {StylingContext} from './interfaces/styling';\nimport {CONTEXT, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, LViewData, LViewFlags, PARENT, RootContext, TData, TVIEW} from './interfaces/view';\n\n\n\n/**\n * Returns whether the values are different from a change detection stand point.\n *\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\n */\nexport function isDifferent(a: any, b: any, checkNoChangesMode: boolean): boolean {\n  if (ngDevMode && checkNoChangesMode) {\n    return !devModeEqual(a, b);\n  }\n  // NaN is the only value that is not equal to itself so the first\n  // test checks if both a and b are not NaN\n  return !(a !== a && b !== b) && a !== b;\n}\n\nexport function stringify(value: any): string {\n  if (typeof value == 'function') return value.name || value;\n  if (typeof value == 'string') return value;\n  if (value == null) return '';\n  return '' + value;\n}\n\n/**\n * Flattens an array in non-recursive way. Input arrays are not modified.\n */\nexport function flatten(list: any[]): any[] {\n  const result: any[] = [];\n  let i = 0;\n\n  while (i < list.length) {\n    const item = list[i];\n    if (Array.isArray(item)) {\n      if (item.length > 0) {\n        list = item.concat(list.slice(i + 1));\n        i = 0;\n      } else {\n        i++;\n      }\n    } else {\n      result.push(item);\n      i++;\n    }\n  }\n\n  return result;\n}\n\n/** Retrieves a value from any `LViewData` or `TData`. */\nexport function loadInternal<T>(index: number, arr: LViewData | TData): T {\n  ngDevMode && assertDataInRangeInternal(index + HEADER_OFFSET, arr);\n  return arr[index + HEADER_OFFSET];\n}\n\nexport function assertDataInRangeInternal(index: number, arr: any[]) {\n  assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');\n}\n\n/**\n * Takes the value of a slot in `LViewData` and returns the element node.\n *\n * Normally, element nodes are stored flat, but if the node has styles/classes on it,\n * it might be wrapped in a styling context. Or if that node has a directive that injects\n * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,\n * it will be wrapped in LViewData. It could even have all three, so we keep looping\n * until we find something that isn't an array.\n *\n * @param value The initial value in `LViewData`\n */\nexport function readElementValue(value: RElement | StylingContext | LContainer | LViewData):\n    RElement {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, arr: LViewData): RElement {\n  return readElementValue(arr[index + HEADER_OFFSET]);\n}\n\nexport function getNativeByTNode(tNode: TNode, hostView: LViewData): RElement|RText|RComment {\n  return readElementValue(hostView[tNode.index]);\n}\n\nexport function getTNode(index: number, view: LViewData): TNode {\n  return view[TVIEW].data[index + HEADER_OFFSET] as TNode;\n}\n\nexport function getComponentViewByIndex(nodeIndex: number, hostView: LViewData): LViewData {\n  // Could be an LViewData or an LContainer. If LContainer, unwrap to find LViewData.\n  const slotValue = hostView[nodeIndex];\n  return slotValue.length >= HEADER_OFFSET ? slotValue : slotValue[HOST];\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isLContainer(value: RElement | RComment | LContainer | StylingContext): boolean {\n  // Styling contexts are also arrays, but their first index contains an element node\n  return Array.isArray(value) && typeof value[ACTIVE_INDEX] === 'number';\n}\n\nexport function isRootView(target: LViewData): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LViewData` until\n * reaching the root `LViewData`.\n *\n * @param component any component\n */\nexport function getRootView(target: LViewData | {}): LViewData {\n  ngDevMode && assertDefined(target, 'component');\n  let lViewData = Array.isArray(target) ? (target as LViewData) : readPatchedLViewData(target) !;\n  while (lViewData && !(lViewData[FLAGS] & LViewFlags.IsRoot)) {\n    lViewData = lViewData[PARENT] !;\n  }\n  return lViewData;\n}\n\nexport function getRootContext(viewOrComponent: LViewData | {}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LViewData|LContext|null {\n  return target[MONKEY_PATCH_KEY_NAME];\n}\n\nexport function readPatchedLViewData(target: any): LViewData|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lViewData;\n  }\n  return null;\n}\n\nexport function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nexport function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n}\n\nexport function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) >> RelativeInjectorLocationFlags.ViewOffsetShift;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LViewData instance from which to start walking up the view tree\n * @returns The LViewData instance that contains the parent injector\n */\nexport function getParentInjectorView(\n    location: RelativeInjectorLocation, startView: LViewData): LViewData {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    viewOffset--;\n  }\n  return parentView;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the TNode of the parent injector is found.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LViewData instance from which to start walking up the view tree\n * @param startTNode The TNode instance of the starting element\n * @returns The TNode of the parent injector\n */\nexport function getParentInjectorTNode(\n    location: RelativeInjectorLocation, startView: LViewData, startTNode: TNode): TElementNode|\n    TContainerNode|null {\n  if (startTNode.parent && startTNode.parent.injectorIndex !== -1) {\n    // view offset is 0\n    const injectorIndex = startTNode.parent.injectorIndex;\n    let parentTNode = startTNode.parent;\n    while (parentTNode.parent != null && injectorIndex == parentTNode.injectorIndex) {\n      parentTNode = parentTNode.parent;\n    }\n    return parentTNode;\n  }\n\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  let parentTNode = startView[HOST_NODE] as TElementNode;\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    parentTNode = parentView[HOST_NODE] as TElementNode;\n    viewOffset--;\n  }\n  return parentTNode;\n}\n\nexport const defaultScheduler =\n    (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame ||  // browser only\n     setTimeout                                                                // everything else\n     ).bind(global);"]}