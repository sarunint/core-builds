{"version":3,"file":"view_ref.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/view_ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef} from '../linker/view_ref';\n\nimport {checkNoChanges, checkNoChangesInRootView, detectChanges, detectChangesInRootView, markViewDirty, storeCleanupFn, viewAttached} from './instructions';\nimport {TViewNode} from './interfaces/node';\nimport {FLAGS, LViewData, LViewFlags, PARENT} from './interfaces/view';\nimport {destroyLView} from './node_manipulation';\nimport {getRendererFactory} from './state';\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n    viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ApplicationRef|null = null;\n  private _viewContainerRef: viewEngine_ViewContainerRef|null = null;\n\n  /**\n   * @internal\n   */\n  _view: LViewData;\n\n  /**\n   * @internal\n   */\n  _tViewNode: TViewNode|null = null;\n\n  // TODO(issue/24571): remove '!'.\n  rootNodes !: any[];\n\n  constructor(_view: LViewData, private _context: T|null, private _componentIndex: number) {\n    this._view = _view;\n  }\n\n  get context(): T { return this._context ? this._context : this._lookUpContext(); }\n\n  get destroyed(): boolean {\n    return (this._view[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._viewContainerRef && viewAttached(this._view)) {\n      this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\n      this._viewContainerRef = null;\n    }\n    destroyLView(this._view);\n  }\n\n  onDestroy(callback: Function) { storeCleanupFn(this._view, callback); }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void { markViewDirty(this._view); }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void { this._view[FLAGS] &= ~LViewFlags.Attached; }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void { this._view[FLAGS] |= LViewFlags.Attached; }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void {\n    const rendererFactory = getRendererFactory();\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    detectChanges(this.context);\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void { checkNoChanges(this.context); }\n\n  attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef) { this._viewContainerRef = vcRef; }\n\n  detachFromAppRef() { this._appRef = null; }\n\n  attachToAppRef(appRef: ApplicationRef) { this._appRef = appRef; }\n\n  private _lookUpContext(): T {\n    return this._context = this._view[PARENT] ![this._componentIndex] as T;\n  }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(public _view: LViewData) { super(_view, null, -1); }\n\n  detectChanges(): void { detectChangesInRootView(this._view); }\n\n  checkNoChanges(): void { checkNoChangesInRootView(this._view); }\n}\n"]}