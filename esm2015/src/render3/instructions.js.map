{"version":3,"file":"instructions.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/instructions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {InjectionToken} from '../di/injection_token';\nimport {InjectFlags} from '../di/injector_compatibility';\nimport {QueryList} from '../linker';\nimport {Sanitizer} from '../sanitization/security';\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {Type} from '../type';\nimport {noop} from '../util/noop';\n\nimport {assertDefined, assertEqual, assertLessThan, assertNotEqual} from './assert';\nimport {attachPatchData, getComponentViewByInstance} from './context_discovery';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateInjectable, getOrCreateNodeInjectorForNode, injectAttributeImpl} from './di';\nimport {throwErrorIfNoChangesMode, throwMultipleComponentError} from './errors';\nimport {executeHooks, executeInitHooks, queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {ACTIVE_INDEX, LContainer, VIEWS} from './interfaces/container';\nimport {ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {INJECTOR_SIZE, NodeInjectorFactory} from './interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode, TViewNode} from './interfaces/node';\nimport {PlayerFactory} from './interfaces/player';\nimport {CssSelectorList, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, RendererFactory3, isProceduralRenderer} from './interfaces/renderer';\nimport {StylingIndex} from './interfaces/styling';\nimport {BINDING_INDEX, CLEANUP, CONTAINER_INDEX, CONTENT_QUERIES, CONTEXT, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, INJECTOR, LViewData, LViewFlags, NEXT, OpaqueViewState, PARENT, QUERIES, RENDERER, RootContext, RootContextFlags, SANITIZER, TAIL, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {appendChild, appendProjectedNode, createTextNode, findComponentView, getLViewChild, getRenderParent, insertView, removeView} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {assertDataInRange, assertHasParent, assertPreviousIsParent, decreaseElementDepthCount, enterView, getBindingsEnabled, getCheckNoChangesMode, getCleanup, getContextViewData, getCreationMode, getCurrentQueries, getCurrentSanitizer, getElementDepthCount, getFirstTemplatePass, getIsParent, getPreviousOrParentTNode, getRenderer, getRendererFactory, getTView, getTViewCleanup, getViewData, increaseElementDepthCount, leaveView, nextContextImpl, resetComponentState, setBindingRoot, setCheckNoChangesMode, setCurrentQueries, setFirstTemplatePass, setIsParent, setPreviousOrParentTNode, setRenderer, setRendererFactory} from './state';\nimport {createStylingContextTemplate, renderStyleAndClassBindings, updateClassProp as updateElementClassProp, updateStyleProp as updateElementStyleProp, updateStylingMap} from './styling/class_and_style_bindings';\nimport {BoundPlayerFactory} from './styling/player_factory';\nimport {getStylingContext} from './styling/util';\nimport {NO_CHANGE} from './tokens';\nimport {getComponentViewByIndex, getNativeByIndex, getNativeByTNode, getRootContext, getRootView, getTNode, isComponent, isComponentDef, isDifferent, loadInternal, readPatchedLViewData, stringify} from './util';\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\ntype SanitizerFn = (value: any) => string;\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings, refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nexport function refreshDescendantViews(viewData: LViewData, rf: RenderFlags | null) {\n  const tView = getTView();\n  const parentFirstTemplatePass = getFirstTemplatePass();\n\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = false;\n  setFirstTemplatePass(false);\n\n  // Dynamically created views must run first only in creation mode. If this is a\n  // creation-only pass, we should not call lifecycle hooks or evaluate bindings.\n  // This will be done in the update-only pass.\n  if (rf !== RenderFlags.Create) {\n    const creationMode = getCreationMode();\n    const checkNoChangesMode = getCheckNoChangesMode();\n\n    if (!checkNoChangesMode) {\n      executeInitHooks(viewData, tView, creationMode);\n    }\n\n    setHostBindings(tView, viewData);\n\n    refreshDynamicEmbeddedViews(viewData);\n\n    // Content query results must be refreshed before content hooks are called.\n    refreshContentQueries(tView);\n\n    if (!checkNoChangesMode) {\n      executeHooks(viewData, tView.contentHooks, tView.contentCheckHooks, creationMode);\n    }\n  }\n\n  refreshChildComponents(tView.components, parentFirstTemplatePass, rf);\n}\n\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(tView: TView, viewData: LViewData): void {\n  if (tView.expandoInstructions) {\n    let bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;\n    setBindingRoot(bindingRootIndex);\n    let currentDirectiveIndex = -1;\n    let currentElementIndex = -1;\n    for (let i = 0; i < tView.expandoInstructions.length; i++) {\n      const instruction = tView.expandoInstructions[i];\n      if (typeof instruction === 'number') {\n        if (instruction <= 0) {\n          // Negative numbers mean that we are starting new EXPANDO block and need to update\n          // the current element and directive index.\n          currentElementIndex = -instruction;\n          // Injector block and providers are taken into account.\n          const providerCount = (tView.expandoInstructions[++i] as number);\n          bindingRootIndex += INJECTOR_SIZE + providerCount;\n\n          currentDirectiveIndex = bindingRootIndex;\n        } else {\n          // This is either the injector size (so the binding root can skip over directives\n          // and get to the first set of host bindings on this node) or the host var count\n          // (to get to the next set of host bindings on this node).\n          bindingRootIndex += instruction;\n        }\n        setBindingRoot(bindingRootIndex);\n      } else {\n        // If it's not a number, it's a host binding function that needs to be executed.\n        viewData[BINDING_INDEX] = bindingRootIndex;\n        // We must subtract the header offset because the load() instruction\n        // expects a raw, unadjusted index.\n        instruction(currentDirectiveIndex - HEADER_OFFSET, currentElementIndex);\n        currentDirectiveIndex++;\n      }\n    }\n  }\n}\n\n/** Refreshes content queries for all directives in the given view. */\nfunction refreshContentQueries(tView: TView): void {\n  if (tView.contentQueries != null) {\n    for (let i = 0; i < tView.contentQueries.length; i += 2) {\n      const directiveDefIdx = tView.contentQueries[i];\n      const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n\n      directiveDef.contentQueriesRefresh !(\n          directiveDefIdx - HEADER_OFFSET, tView.contentQueries[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(\n    components: number[] | null, parentFirstTemplatePass: boolean, rf: RenderFlags | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i++) {\n      componentRefresh(components[i], parentFirstTemplatePass, rf);\n    }\n  }\n}\n\nexport function createLViewData<T>(\n    renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags,\n    sanitizer?: Sanitizer | null): LViewData {\n  const viewData = getViewData();\n  const instance = tView.blueprint.slice() as LViewData;\n  instance[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.RunInit;\n  instance[PARENT] = instance[DECLARATION_VIEW] = viewData;\n  instance[CONTEXT] = context;\n  instance[INJECTOR] = viewData ? viewData[INJECTOR] : null;\n  instance[RENDERER] = renderer;\n  instance[SANITIZER] = sanitizer || null;\n  return instance;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null,\n    attrs: TAttributes | null): TElementNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Container, native: RComment, name: string | null,\n    attrs: TAttributes | null): TContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Projection, native: null, name: null,\n    attrs: TAttributes | null): TProjectionNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.ElementContainer, native: RComment, name: null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType, native: RText | RElement | RComment | null, name: string | null,\n    attrs: TAttributes | null): TElementNode&TContainerNode&TElementContainerNode&TProjectionNode {\n  const viewData = getViewData();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode &&\n      assertLessThan(adjustedIndex, viewData.length, `Slot should have been initialized with null`);\n  viewData[adjustedIndex] = native;\n\n  let tNode = tView.data[adjustedIndex] as TNode;\n  if (tNode == null) {\n    const previousOrParentTNode = getPreviousOrParentTNode();\n    const isParent = getIsParent();\n    tNode = tView.data[adjustedIndex] =\n        createTNode(viewData, type, adjustedIndex, name, attrs, null);\n\n    // Now link ourselves into the tree.\n    if (previousOrParentTNode) {\n      if (isParent && previousOrParentTNode.child == null &&\n          (tNode.parent !== null || previousOrParentTNode.type === TNodeType.View)) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        previousOrParentTNode.child = tNode;\n      } else if (!isParent) {\n        previousOrParentTNode.next = tNode;\n      }\n    }\n  }\n\n  if (tView.firstChild == null && type === TNodeType.Element) {\n    tView.firstChild = tNode;\n  }\n\n  setPreviousOrParentTNode(tNode);\n  setIsParent(true);\n  return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n      TProjectionNode;\n}\n\nexport function createViewNode(index: number, view: LViewData) {\n  // View nodes are not stored in data because they can be added / removed at runtime (which\n  // would cause indices to change). Their TNodes are instead stored in tView.node.\n  if (view[TVIEW].node == null) {\n    view[TVIEW].node = createTNode(view, TNodeType.View, index, null, null, null) as TViewNode;\n  }\n\n  setIsParent(true);\n  const tNode = view[TVIEW].node as TViewNode;\n  setPreviousOrParentTNode(tNode);\n  return view[HOST_NODE] = tNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n */\nexport function adjustBlueprintForNewNode(view: LViewData) {\n  const tView = view[TVIEW];\n  if (tView.firstTemplatePass) {\n    tView.expandoStartIndex++;\n    tView.blueprint.push(null);\n    view.push(null);\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param templateFn Template function with the instructions.\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T,\n    providedRendererFactory: RendererFactory3, hostView: LViewData | null,\n    directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null,\n    sanitizer?: Sanitizer | null): LViewData {\n  if (hostView == null) {\n    resetComponentState();\n    setRendererFactory(providedRendererFactory);\n    const renderer = providedRendererFactory.createRenderer(null, null);\n    setRenderer(renderer);\n\n    // We need to create a root view so it's possible to look up the host element through its index\n    enterView(\n        createLViewData(\n            renderer, createTView(-1, null, 1, 0, null, null, null), {},\n            LViewFlags.CheckAlways | LViewFlags.IsRoot),\n        null);\n\n    const componentTView =\n        getOrCreateTView(templateFn, consts, vars, directives || null, pipes || null, null);\n    hostView =\n        createLViewData(renderer, componentTView, context, LViewFlags.CheckAlways, sanitizer);\n    hostView[HOST_NODE] = createNodeAtIndex(0, TNodeType.Element, hostNode, null, null);\n  }\n  renderComponentOrTemplate(hostView, context, null, templateFn);\n\n  return hostView;\n}\n\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport function createEmbeddedViewAndNode<T>(\n    tView: TView, context: T, declarationView: LViewData, renderer: Renderer3,\n    queries: LQueries | null, injectorIndex: number): LViewData {\n  const _isParent = getIsParent();\n  const _previousOrParentTNode = getPreviousOrParentTNode();\n  setIsParent(true);\n  setPreviousOrParentTNode(null !);\n\n  const lView =\n      createLViewData(renderer, tView, context, LViewFlags.CheckAlways, getCurrentSanitizer());\n  lView[DECLARATION_VIEW] = declarationView;\n\n  if (queries) {\n    lView[QUERIES] = queries.createView();\n  }\n  createViewNode(-1, lView);\n\n  if (tView.firstTemplatePass) {\n    tView.node !.injectorIndex = injectorIndex;\n  }\n\n  setIsParent(_isParent);\n  setPreviousOrParentTNode(_previousOrParentTNode);\n  return lView;\n}\n\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport function renderEmbeddedTemplate<T>(\n    viewToRender: LViewData, tView: TView, context: T, rf: RenderFlags) {\n  const _isParent = getIsParent();\n  const _previousOrParentTNode = getPreviousOrParentTNode();\n  setIsParent(true);\n  setPreviousOrParentTNode(null !);\n  let oldView: LViewData;\n  if (viewToRender[FLAGS] & LViewFlags.IsRoot) {\n    // This is a root view inside the view tree\n    tickRootContext(getRootContext(viewToRender));\n  } else {\n    try {\n      setIsParent(true);\n      setPreviousOrParentTNode(null !);\n\n      oldView = enterView(viewToRender, viewToRender[HOST_NODE]);\n      namespaceHTML();\n      tView.template !(rf, context);\n      if (rf & RenderFlags.Update) {\n        refreshDescendantViews(viewToRender, null);\n      } else {\n        // This must be set to false immediately after the first creation run because in an\n        // ngFor loop, all the views will be created together before update mode runs and turns\n        // off firstTemplatePass. If we don't set it here, instances will perform directive\n        // matching, etc again and again.\n        viewToRender[TVIEW].firstTemplatePass = false;\n        setFirstTemplatePass(false);\n      }\n    } finally {\n      // renderEmbeddedTemplate() is called twice, once for creation only and then once for\n      // update. When for creation only, leaveView() must not trigger view hooks, nor clean flags.\n      const isCreationOnly = (rf & RenderFlags.Create) === RenderFlags.Create;\n      leaveView(oldView !, isCreationOnly);\n      setIsParent(_isParent);\n      setPreviousOrParentTNode(_previousOrParentTNode);\n    }\n  }\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n */\nexport function nextContext<T = any>(level: number = 1): T {\n  return nextContextImpl(level);\n}\n\nfunction renderComponentOrTemplate<T>(\n    hostView: LViewData, componentOrContext: T, rf: RenderFlags | null,\n    templateFn?: ComponentTemplate<T>) {\n  const rendererFactory = getRendererFactory();\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  try {\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (templateFn) {\n      namespaceHTML();\n      templateFn(rf || getRenderFlags(hostView), componentOrContext !);\n    }\n    refreshDescendantViews(hostView, rf);\n  } finally {\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. By default, the update block is run with the\n * creation block when the view is in creation mode. Otherwise, the update block is run\n * alone.\n *\n * Dynamically created views do NOT use this configuration (update block and create block are\n * always run separately).\n */\nfunction getRenderFlags(view: LViewData): RenderFlags {\n  return view[FLAGS] & LViewFlags.CreationMode ? RenderFlags.Create | RenderFlags.Update :\n                                                 RenderFlags.Update;\n}\n\n//////////////////////////\n//// Namespace\n//////////////////////////\n\nlet _currentNamespace: string|null = null;\n\nexport function namespaceSVG() {\n  _currentNamespace = 'http://www.w3.org/2000/svg/';\n}\n\nexport function namespaceMathML() {\n  _currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\nexport function namespaceHTML() {\n  _currentNamespace = null;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function element(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  elementStart(index, name, attrs, localRefs);\n  elementEnd();\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param attrs Set of attributes to be used when matching directives.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n */\nexport function elementContainerStart(\n    index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  const viewData = getViewData();\n  const tView = getTView();\n  const renderer = getRenderer();\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'element containers should be created before any bindings');\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = renderer.createComment(ngDevMode ? 'ng-container' : '');\n\n  ngDevMode && assertDataInRange(index - 1);\n  const tNode = createNodeAtIndex(index, TNodeType.ElementContainer, native, null, attrs || null);\n\n  appendChild(native, tNode, viewData);\n  createDirectivesAndLocals(tView, viewData, localRefs);\n}\n\n/** Mark the end of the <ng-container>. */\nexport function elementContainerEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  const tView = getTView();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.ElementContainer);\n  const currentQueries = getCurrentQueries();\n  if (currentQueries) {\n    setCurrentQueries(currentQueries.addNode(previousOrParentTNode as TElementContainerNode));\n  }\n\n  queueLifecycleHooks(previousOrParentTNode.flags, tView);\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  const viewData = getViewData();\n  const tView = getTView();\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'elements should be created before any bindings ');\n\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  const native = elementCreate(name);\n\n  ngDevMode && assertDataInRange(index - 1);\n\n  const tNode = createNodeAtIndex(index, TNodeType.Element, native !, name, attrs || null);\n\n  if (attrs) {\n    setUpAttributes(native, attrs);\n  }\n\n  appendChild(native, tNode, viewData);\n  createDirectivesAndLocals(tView, viewData, localRefs);\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, viewData);\n  }\n  increaseElementDepthCount();\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement {\n  let native: RElement;\n  const rendererToUse = overriddenRenderer || getRenderer();\n\n  if (isProceduralRenderer(rendererToUse)) {\n    native = rendererToUse.createElement(name, _currentNamespace);\n  } else {\n    if (_currentNamespace === null) {\n      native = rendererToUse.createElement(name);\n    } else {\n      native = rendererToUse.createElementNS(_currentNamespace, name);\n    }\n  }\n  return native;\n}\n\n/**\n * Creates directive instances and populates local refs.\n *\n * @param localRefs Local refs of the node in question\n * @param localRefExtractor mapping function that extracts local ref value from TNode\n */\nfunction createDirectivesAndLocals(\n    tView: TView, viewData: LViewData, localRefs: string[] | null | undefined,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode) {\n  if (!getBindingsEnabled()) return;\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  if (getFirstTemplatePass()) {\n    ngDevMode && ngDevMode.firstTemplatePass++;\n\n    resolveDirectives(\n        tView, viewData, findDirectiveMatches(tView, viewData, previousOrParentTNode),\n        previousOrParentTNode, localRefs || null);\n  }\n  instantiateAllDirectives(tView, viewData, previousOrParentTNode);\n  saveResolvedLocalsInData(viewData, previousOrParentTNode, localRefExtractor);\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LViewData in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(\n    viewData: LViewData, tNode: TNode, localRefExtractor: LocalRefExtractor): void {\n  const localNames = tNode.localNames;\n  if (localNames) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param templateFn The template from which to get static data\n * @param consts The number of nodes, local refs, and pipes in this view\n * @param vars The number of bindings and pure function bindings in this view\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nexport function getOrCreateTView(\n    templateFn: ComponentTemplate<any>, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\n  // 1. It is a megamorphic call on each invocation.\n  // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\n  //    outer template invocation, which means that no such property will exist\n  // Correct solution is to only put `ngPrivateData` on the Component template\n  // and not on embedded templates.\n\n  return templateFn.ngPrivateData ||\n      (templateFn.ngPrivateData =\n           createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery) as never);\n}\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport function createTView(\n    viewIndex: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + consts;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW] = {\n    id: viewIndex,\n    blueprint: blueprint,\n    template: templateFn,\n    viewQuery: viewQuery,\n    node: null !,\n    data: blueprint.slice(),  // Fill in to match HEADER_OFFSET in LViewData\n    childIndex: -1,           // Children set in addToViewTree(), if any\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    expandoInstructions: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    firstChild: null,\n  };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LViewData {\n  const blueprint = new Array(initialViewLength)\n                        .fill(null, 0, bindingStartIndex)\n                        .fill(NO_CHANGE, bindingStartIndex) as LViewData;\n  blueprint[CONTAINER_INDEX] = -1;\n  blueprint[BINDING_INDEX] = bindingStartIndex;\n  return blueprint;\n}\n\nfunction setUpAttributes(native: RElement, attrs: TAttributes): void {\n  const renderer = getRenderer();\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === NG_PROJECT_AS_ATTR_NAME) {\n      i += 2;\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (attrName === AttributeMarker.NamespaceURI) {\n        // Namespaced attributes\n        const namespaceURI = attrs[i + 1] as string;\n        const attrName = attrs[i + 2] as string;\n        const attrVal = attrs[i + 3] as string;\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName, attrVal, namespaceURI) :\n            native.setAttributeNS(namespaceURI, attrName, attrVal);\n        i += 4;\n      } else {\n        // Standard attributes\n        const attrVal = attrs[i + 1];\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName as string, attrVal as string) :\n            native.setAttribute(attrName as string, attrVal as string);\n        i += 2;\n      }\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  ngDevMode && assertDataInRange(-1);\n  setRendererFactory(factory);\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  const viewData = getViewData();\n  const tNode = getPreviousOrParentTNode();\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer);\n\n  // add native event listener - applicable to elements only\n  if (tNode.type === TNodeType.Element) {\n    const native = getNativeByTNode(tNode, viewData) as RElement;\n    ngDevMode && ngDevMode.rendererAddEventListener++;\n    const renderer = getRenderer();\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      const cleanupFn = renderer.listen(native, eventName, listenerFn);\n      storeCleanupFn(viewData, cleanupFn);\n    } else {\n      const wrappedListener = wrapListenerWithPreventDefault(listenerFn);\n      native.addEventListener(eventName, wrappedListener, useCapture);\n      const cleanupInstances = getCleanup(viewData);\n      cleanupInstances.push(wrappedListener);\n      if (getFirstTemplatePass()) {\n        getTViewCleanup(viewData).push(\n            eventName, tNode.index, cleanupInstances !.length - 1, useCapture);\n      }\n    }\n  }\n\n  // subscribe to directive outputs\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(tNode.flags, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let outputData: PropertyAliasValue|undefined;\n  if (outputs && (outputData = outputs[eventName])) {\n    createOutput(viewData, outputData, listenerFn);\n  }\n}\n\n/**\n * Iterates through the outputs associated with a particular event name and subscribes to\n * each output.\n */\nfunction createOutput(viewData: LViewData, outputs: PropertyAliasValue, listener: Function): void {\n  for (let i = 0; i < outputs.length; i += 2) {\n    ngDevMode && assertDataInRange(outputs[i] as number, viewData);\n    const subscription = viewData[outputs[i] as number][outputs[i + 1]].subscribe(listener);\n    storeCleanupWithContext(viewData, subscription, subscription.unsubscribe);\n  }\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(\n    view: LViewData | null, context: any, cleanupFn: Function): void {\n  if (!view) view = getViewData();\n  getCleanup(view).push(context);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(cleanupFn, view[CLEANUP] !.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LViewData, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Element);\n  const currentQueries = getCurrentQueries();\n  if (currentQueries) {\n    setCurrentQueries(currentQueries.addNode(previousOrParentTNode as TElementNode));\n  }\n\n  queueLifecycleHooks(previousOrParentTNode.flags, getTView());\n  decreaseElementDepthCount();\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: SanitizerFn): void {\n  if (value !== NO_CHANGE) {\n    const viewData = getViewData();\n    const renderer = getRenderer();\n    const element = getNativeByIndex(index, viewData);\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveAttribute++;\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name) :\n                                       element.removeAttribute(name);\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element, name, strValue) :\n                                       element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\n\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn): void {\n  if (value === NO_CHANGE) return;\n  const viewData = getViewData();\n  const element = getNativeByIndex(index, viewData) as RElement | RComment;\n  const tNode = getTNode(index, viewData);\n  const inputData = initializeTNodeInputs(tNode);\n  let dataValue: PropertyAliasValue|undefined;\n  if (inputData && (dataValue = inputData[propName])) {\n    setInputsForProperty(viewData, dataValue, value);\n    if (isComponent(tNode)) markDirtyIfOnPush(viewData, index + HEADER_OFFSET);\n  } else if (tNode.type === TNodeType.Element) {\n    const renderer = getRenderer();\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    ngDevMode && ngDevMode.rendererSetProperty++;\n    isProceduralRenderer(renderer) ?\n        renderer.setProperty(element as RElement, propName, value) :\n        ((element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                             (element as any)[propName] = value);\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    viewData: LViewData, type: TNodeType, adjustedIndex: number, tagName: string | null,\n    attrs: TAttributes | null, tViews: TView[] | null): TNode {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  ngDevMode && ngDevMode.tNode++;\n  const parent =\n      getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const parentInSameView = parent && viewData && parent !== viewData[HOST_NODE];\n  const tParent = parentInSameView ? parent as TElementNode | TContainerNode : null;\n\n  return {\n    type: type,\n    index: adjustedIndex,\n    injectorIndex: tParent ? tParent.injectorIndex : -1,\n    flags: 0,\n    providerIndexes: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    tViews: tViews,\n    next: null,\n    child: null,\n    parent: tParent,\n    detached: null,\n    stylingTemplate: null,\n    projection: null\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(viewData: LViewData, inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(inputs[i] as number, viewData);\n    viewData[inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param number tNodeFlags node flags\n * @param Direction direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(\n    tNodeFlags: TNodeFlags, direction: BindingDirection): PropertyAliases|null {\n  const tView = getTView();\n  const count = tNodeFlags & TNodeFlags.DirectiveCountMask;\n  let propStore: PropertyAliases|null = null;\n\n  if (count > 0) {\n    const start = tNodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const isInput = direction === BindingDirection.Input;\n    const defs = tView.data;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDef<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n */\nexport function elementClassProp(\n    index: number, stylingIndex: number, value: boolean | PlayerFactory): void {\n  const val =\n      (value instanceof BoundPlayerFactory) ? (value as BoundPlayerFactory<boolean>) : (!!value);\n  updateElementClassProp(getStylingContext(index, getViewData()), stylingIndex, val);\n}\n\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to apply all styling\n * (e.g. `style=\"...\"`) values to the element. This is also where the provided index\n * value is allocated for the styling details for its corresponding element (the element\n * index is the previous index value from this one).\n *\n * (Note this function calls `elementStylingApply` immediately when called.)\n *\n *\n * @param index Index value which will be allocated to store styling data for the element.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\n *   class value that are passed in here will be applied to the element (if matched).\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\n *   bindings. If a style binding changes its value to null then the initial styling\n *   values that are passed in here will be applied to the element (if matched).\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\n */\nexport function elementStyling(\n    classDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): void {\n  const tNode = getPreviousOrParentTNode();\n  const inputData = initializeTNodeInputs(tNode);\n\n  if (!tNode.stylingTemplate) {\n    const hasClassInput = inputData && inputData.hasOwnProperty('class') ? true : false;\n    if (hasClassInput) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n\n    // initialize the styling template.\n    tNode.stylingTemplate = createStylingContextTemplate(\n        classDeclarations, styleDeclarations, styleSanitizer, hasClassInput);\n  }\n\n  if (styleDeclarations && styleDeclarations.length ||\n      classDeclarations && classDeclarations.length) {\n    const index = tNode.index - HEADER_OFFSET;\n    if (delegateToClassInput(tNode)) {\n      const stylingContext = getStylingContext(index, getViewData());\n      const initialClasses = stylingContext[StylingIndex.PreviousOrCachedMultiClassValue] as string;\n      setInputsForProperty(getViewData(), tNode.inputs !['class'] !, initialClasses);\n    }\n    elementStylingApply(index);\n  }\n}\n\n\n/**\n * Apply all styling values to the element which have been queued by any styling instructions.\n *\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\n * have been issued against the element. This function will also determine if any styles have\n * changed and will then skip the operation if there is nothing new to render.\n *\n * Once called then all queued styles will be flushed.\n *\n * @param index Index of the element's styling storage that will be rendered.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n */\nexport function elementStylingApply(index: number): void {\n  const viewData = getViewData();\n  const isFirstRender = (viewData[FLAGS] & LViewFlags.CreationMode) !== 0;\n  const totalPlayersQueued = renderStyleAndClassBindings(\n      getStylingContext(index, viewData), getRenderer(), viewData, isFirstRender);\n  if (totalPlayersQueued > 0) {\n    const rootContext = getRootContext(viewData);\n    scheduleTick(rootContext, RootContextFlags.FlushPlayers);\n  }\n}\n\n/**\n * Queue a given style to be rendered on an Element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n */\nexport function elementStyleProp(\n    index: number, styleIndex: number, value: string | number | String | PlayerFactory | null,\n    suffix?: string): void {\n  let valueToAdd: string|null = null;\n  if (value) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      valueToAdd = stringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a String value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      valueToAdd = value as any as string;\n    }\n  }\n  updateElementStyleProp(getStylingContext(index, getViewData()), styleIndex, valueToAdd);\n}\n\n/**\n * Queue a key/value map of styles to be rendered on an Element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage. When styles are applied to\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\n * If any styles are set to `null` then they will be removed from the element (unless the same\n * style properties have been assigned to the element during creation using `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n */\nexport function elementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | NO_CHANGE | null,\n    styles?: {[styleName: string]: any} | NO_CHANGE | null): void {\n  const viewData = getViewData();\n  const tNode = getTNode(index, viewData);\n  const stylingContext = getStylingContext(index, viewData);\n  if (delegateToClassInput(tNode) && classes !== NO_CHANGE) {\n    const initialClasses = stylingContext[StylingIndex.PreviousOrCachedMultiClassValue] as string;\n    const classInputVal =\n        (initialClasses.length ? (initialClasses + ' ') : '') + (classes as string);\n    setInputsForProperty(getViewData(), tNode.inputs !['class'] !, classInputVal);\n  }\n  updateStylingMap(stylingContext, classes, styles);\n}\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  const viewData = getViewData();\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], getTView().bindingStartIndex,\n                   'text nodes should be created before any bindings');\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  const textNative = createTextNode(value, getRenderer());\n  const tNode = createNodeAtIndex(index, TNodeType.Element, textNative, null, null);\n\n  // Text nodes are self closing.\n  setIsParent(false);\n  appendChild(textNative, tNode, viewData);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    ngDevMode && assertDataInRange(index + HEADER_OFFSET);\n    const element = getNativeByIndex(index, getViewData()) as any as RText;\n    ngDevMode && assertDefined(element, 'native element should exist');\n    ngDevMode && ngDevMode.rendererSetText++;\n    const renderer = getRenderer();\n    isProceduralRenderer(renderer) ? renderer.setValue(element, stringify(value)) :\n                                     element.textContent = stringify(value);\n  }\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(\n    tView: TView, viewData: LViewData, def: ComponentDef<T>): T {\n  const rootTNode = getPreviousOrParentTNode();\n  if (tView.firstTemplatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    generateExpandoInstructionBlock(tView, rootTNode, 1);\n    baseResolveDirective(tView, viewData, def, def.factory);\n  }\n  const directive =\n      getNodeInjectable(tView.data, viewData, viewData.length - 1, rootTNode as TElementNode);\n  postProcessBaseDirective(viewData, rootTNode, directive, def as DirectiveDef<T>);\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(\n    tView: TView, viewData: LViewData, directives: DirectiveDef<any>[] | null, tNode: TNode,\n    localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'should run on first template pass only');\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  let totalHostVars = 0;\n  if (directives) {\n    initNodeFlags(tNode, tView.data.length, directives.length);\n    // When the same token is provided by several directives on the same node, some rules apply in\n    // the viewEngine:\n    // - viewProviders have priority over providers\n    // - the last directive in NgModule.declarations has priority over the previous one\n    // So to match these rules, the order in which providers are added in the arrays is very\n    // important.\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n      if (def.providersResolver) def.providersResolver(def);\n    }\n    generateExpandoInstructionBlock(tView, tNode, directives.length);\n    for (let i = 0; i < directives.length; i++) {\n      const def = directives[i] as DirectiveDef<any>;\n\n      const directiveDefIdx = tView.data.length;\n      baseResolveDirective(tView, viewData, def, def.factory);\n\n      totalHostVars += def.hostVars;\n      saveNameToExportMap(tView.data !.length - 1, def, exportsMap);\n\n      // Init hooks are queued now so ngOnInit is called in host components before\n      // any projected components.\n      queueInitHooks(directiveDefIdx, def.onInit, def.doCheck, tView);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  prefillHostVars(tView, viewData, totalHostVars);\n}\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView: TView, viewData: LViewData, previousOrParentTNode: TNode) {\n  const start = previousOrParentTNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n  const end = start + previousOrParentTNode.flags & TNodeFlags.DirectiveCountMask;\n  if (!getFirstTemplatePass() && start < end) {\n    getOrCreateNodeInjectorForNode(\n        previousOrParentTNode as TElementNode | TContainerNode | TElementContainerNode, viewData);\n  }\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    if (isComponentDef(def)) {\n      addComponentLogic(viewData, previousOrParentTNode, def as ComponentDef<any>);\n    }\n    const directive =\n        getNodeInjectable(tView.data, viewData !, i, previousOrParentTNode as TElementNode);\n    postProcessDirective(viewData, directive, def, i);\n  }\n}\n\n/**\n* Generates a new block in TView.expandoInstructions for this node.\n*\n* Each expando block starts with the element index (turned negative so we can distinguish\n* it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n*/\nexport function generateExpandoInstructionBlock(\n    tView: TView, tNode: TNode, directiveCount: number): void {\n  ngDevMode && assertEqual(\n                   tView.firstTemplatePass, true,\n                   'Expando block should only be generated on first template pass.');\n\n  const elementIndex = -(tNode.index - HEADER_OFFSET);\n  const providerStartIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const providerCount = tView.data.length - providerStartIndex;\n  (tView.expandoInstructions || (tView.expandoInstructions = [\n   ])).push(elementIndex, providerCount, directiveCount);\n}\n\n/**\n* On the first template pass, we need to reserve space for host binding values\n* after directives are matched (so all directives are saved, then bindings).\n* Because we are updating the blueprint, we only need to do this once.\n*/\nexport function prefillHostVars(tView: TView, viewData: LViewData, totalHostVars: number): void {\n  for (let i = 0; i < totalHostVars; i++) {\n    viewData.push(NO_CHANGE);\n    tView.blueprint.push(NO_CHANGE);\n    tView.data.push(null);\n  }\n}\n\n/**\n * Process a directive on the current node after its creation.\n */\nfunction postProcessDirective<T>(\n    viewData: LViewData, directive: T, def: DirectiveDef<T>, directiveDefIdx: number): void {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  postProcessBaseDirective(viewData, previousOrParentTNode, directive, def);\n  ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');\n  if (previousOrParentTNode && previousOrParentTNode.attrs) {\n    setInputsFromAttrs(directiveDefIdx, directive, def.inputs, previousOrParentTNode);\n  }\n\n  if (def.contentQueries) {\n    def.contentQueries(directiveDefIdx);\n  }\n\n  if (isComponentDef(def)) {\n    const componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);\n    componentView[CONTEXT] = directive;\n  }\n}\n\n/**\n * A lighter version of postProcessDirective() that is used for the root component.\n */\nfunction postProcessBaseDirective<T>(\n    viewData: LViewData, previousOrParentTNode: TNode, directive: T, def: DirectiveDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, viewData);\n\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], getTView().bindingStartIndex,\n                   'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent();\n\n  attachPatchData(directive, viewData);\n  if (native) {\n    attachPatchData(native, viewData);\n  }\n\n  // TODO(misko): setUpAttributes should be a feature for better treeshakability.\n  if (def.attributes != null && previousOrParentTNode.type == TNodeType.Element) {\n    setUpAttributes(native as RElement, def.attributes as string[]);\n  }\n}\n\n\n\n/**\n* Matches the current node against all available selectors.\n* If a component is matched (at most one), it is returned in first position in the array.\n*/\nfunction findDirectiveMatches(tView: TView, viewData: LViewData, tNode: TNode): DirectiveDef<any>[]|\n    null {\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'should run on first template pass only');\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors !)) {\n        matches || (matches = []);\n        diPublicInInjector(\n            getOrCreateNodeInjectorForNode(\n                getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode,\n                viewData),\n            viewData, def.type);\n\n        if (isComponentDef(def)) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          tNode.flags = TNodeFlags.isComponent;\n\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nexport function queueComponentIndexForCheck(previousOrParentTNode: TNode): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  const tView = getTView();\n  (tView.components || (tView.components = [])).push(previousOrParentTNode.index);\n}\n\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\n*/\nfunction queueHostBindingForCheck(tView: TView, def: DirectiveDef<any>| ComponentDef<any>): void {\n  ngDevMode &&\n      assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');\n  tView.expandoInstructions !.push(def.hostBindings || noop);\n  if (def.hostVars) tView.expandoInstructions !.push(def.hostVars);\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n* Builds up an export map as directives are created, so local refs can be quickly mapped\n* to their directive instances.\n*/\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDef<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode && assertEqual(getFirstTemplatePass(), true, 'expected firstTemplatePass to be true');\n  const flags = tNode.flags;\n  ngDevMode && assertEqual(\n                   flags === 0 || flags === TNodeFlags.isComponent, true,\n                   'expected node flags to not be initialized');\n\n  ngDevMode && assertNotEqual(\n                   numberOfDirectives, TNodeFlags.DirectiveCountMask,\n                   'Reached the max number of directives');\n  // When the first directive is created on a node, save the index\n  tNode.flags = index << TNodeFlags.DirectiveStartingIndexShift | flags & TNodeFlags.isComponent |\n      numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\nfunction baseResolveDirective<T>(\n    tView: TView, viewData: LViewData, def: DirectiveDef<T>,\n    directiveFactory: (t: Type<T>| null) => any) {\n  tView.data.push(def);\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\n  tView.blueprint.push(nodeInjectorFactory);\n  viewData.push(nodeInjectorFactory);\n\n  queueHostBindingForCheck(tView, def);\n}\n\nfunction addComponentLogic<T>(\n    viewData: LViewData, previousOrParentTNode: TNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, viewData);\n\n  const tView = getOrCreateTView(\n      def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const componentView = addToViewTree(\n      viewData, previousOrParentTNode.index as number,\n      createLViewData(\n          getRendererFactory().createRenderer(native as RElement, def), tView, null,\n          def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, getCurrentSanitizer()));\n\n  componentView[HOST_NODE] = previousOrParentTNode as TElementNode;\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  componentView[HOST] = viewData[previousOrParentTNode.index];\n  viewData[previousOrParentTNode.index] = componentView;\n\n  if (getFirstTemplatePass()) {\n    queueComponentIndexForCheck(previousOrParentTNode);\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[P in keyof T]: string;}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    }\n    const minifiedInputName = inputs[attrName];\n    const attrValue = attrs[i + 1];\n\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrValue as string);\n    }\n\n    i += 2;\n  }\n  return initialInputData;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement | RComment,\n    hostTNode: TElementNode | TContainerNode | TElementContainerNode, currentView: LViewData,\n    native: RComment, isForViewContainerRef?: boolean): LContainer {\n  return [\n    isForViewContainerRef ? -1 : 0,          // active index\n    [],                                      // views\n    currentView,                             // parent\n    null,                                    // next\n    null,                                    // queries\n    hostNative,                              // host native\n    native,                                  // native\n    getRenderParent(hostTNode, currentView)  // renderParent\n  ];\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param consts The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n */\nexport function template(\n    index: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null,\n    localRefExtractor?: LocalRefExtractor) {\n  const viewData = getViewData();\n  const tView = getTView();\n  // TODO: consider a separate node type for templates\n  const tNode = containerInternal(index, tagName || null, attrs || null);\n\n  if (getFirstTemplatePass()) {\n    tNode.tViews = createTView(\n        -1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n\n  createDirectivesAndLocals(tView, viewData, localRefs, localRefExtractor);\n  const currentQueries = getCurrentQueries();\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  if (currentQueries) {\n    setCurrentQueries(currentQueries.addNode(previousOrParentTNode as TContainerNode));\n  }\n  queueLifecycleHooks(tNode.flags, tView);\n  setIsParent(false);\n}\n\n/**\n * Creates an LContainer for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n */\nexport function container(index: number): void {\n  const tNode = containerInternal(index, null, null);\n  getFirstTemplatePass() && (tNode.tViews = []);\n  setIsParent(false);\n}\n\nfunction containerInternal(\n    index: number, tagName: string | null, attrs: TAttributes | null): TNode {\n  const viewData = getViewData();\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], getTView().bindingStartIndex,\n                   'container nodes should be created before any bindings');\n\n  const adjustedIndex = index + HEADER_OFFSET;\n  const comment = getRenderer().createComment(ngDevMode ? 'container' : '');\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const tNode = createNodeAtIndex(index, TNodeType.Container, comment, tagName, attrs);\n  const lContainer = viewData[adjustedIndex] =\n      createLContainer(viewData[adjustedIndex], tNode, viewData, comment);\n\n  appendChild(comment, tNode, viewData);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(viewData, index + HEADER_OFFSET, lContainer);\n\n  const currentQueries = getCurrentQueries();\n  if (currentQueries) {\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer[QUERIES] = currentQueries.container();\n  }\n\n  ngDevMode && assertNodeType(getPreviousOrParentTNode(), TNodeType.Container);\n  return tNode;\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  const viewData = getViewData();\n  const tView = getTView();\n  let previousOrParentTNode = loadInternal(index, tView.data) as TNode;\n  setPreviousOrParentTNode(previousOrParentTNode);\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n  setIsParent(true);\n\n  viewData[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\n\n  if (!getCheckNoChangesMode()) {\n    // We need to execute init hooks here so ngOnInit hooks are called in top level views\n    // before they are called in embedded views (for backwards compatibility).\n    executeInitHooks(viewData, tView, getCreationMode());\n  }\n}\n\n/**\n * Marks the end of the LContainer.\n *\n * Marking the end of LContainer is the time when to child views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  let previousOrParentTNode = getPreviousOrParentTNode();\n  if (getIsParent()) {\n    setIsParent(false);\n  } else {\n    ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.View);\n    ngDevMode && assertHasParent();\n    previousOrParentTNode = previousOrParentTNode.parent !;\n    setPreviousOrParentTNode(previousOrParentTNode);\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n\n  const lContainer = getViewData()[previousOrParentTNode.index];\n  const nextIndex = lContainer[ACTIVE_INDEX];\n\n  // remove extra views at the end of the container\n  while (nextIndex < lContainer[VIEWS].length) {\n    removeView(lContainer, previousOrParentTNode as TContainerNode, nextIndex);\n  }\n}\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\n * by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lViewData: LViewData) {\n  for (let current = getLViewChild(lViewData); current !== null; current = current[NEXT]) {\n    // Note: current can be an LViewData or an LContainer instance, but here we are only interested\n    // in LContainer. We can tell it's an LContainer because its length is less than the LViewData\n    // header.\n    if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {\n      const container = current as LContainer;\n      for (let i = 0; i < container[VIEWS].length; i++) {\n        const dynamicViewData = container[VIEWS][i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\n        renderEmbeddedTemplate(\n            dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT] !,\n            RenderFlags.Update);\n      }\n    }\n  }\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param lContainer to search for views\n * @param tContainerNode to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    lContainer: LContainer, tContainerNode: TContainerNode, startIdx: number,\n    viewBlockId: number): LViewData|null {\n  const views = lContainer[VIEWS];\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i][TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(lContainer, tContainerNode, i);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the searchdef.cont here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags {\n  const viewData = getViewData();\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  // The previous node can be a view node if we are processing an inline for loop\n  const containerTNode = previousOrParentTNode.type === TNodeType.View ?\n      previousOrParentTNode.parent ! :\n      previousOrParentTNode;\n  const lContainer = viewData[containerTNode.index] as LContainer;\n\n  ngDevMode && assertNodeType(containerTNode, TNodeType.Container);\n  let viewToRender = scanForView(\n      lContainer, containerTNode as TContainerNode, lContainer[ACTIVE_INDEX] !, viewBlockId);\n\n  if (viewToRender) {\n    setIsParent(true);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    viewToRender = createLViewData(\n        getRenderer(),\n        getOrCreateEmbeddedTView(viewBlockId, consts, vars, containerTNode as TContainerNode), null,\n        LViewFlags.CheckAlways, getCurrentSanitizer());\n\n    if (lContainer[QUERIES]) {\n      viewToRender[QUERIES] = lContainer[QUERIES] !.createView();\n    }\n\n    createViewNode(viewBlockId, viewToRender);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  }\n  if (lContainer) {\n    if (getCreationMode()) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(viewToRender, lContainer, viewData, lContainer[ACTIVE_INDEX] !, -1);\n    }\n    lContainer[ACTIVE_INDEX] !++;\n  }\n  return getRenderFlags(viewToRender);\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param vars The number of bindings and pure function bindings in this template\n * @param container The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(\n    viewIndex: number, consts: number, vars: number, parent: TContainerNode): TView {\n  const tView = getTView();\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = parent.tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] = createTView(\n        viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n  return containerTViews[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  const viewData = getViewData();\n  const viewHost = viewData[HOST_NODE];\n  refreshDescendantViews(viewData, null);\n  leaveView(viewData[PARENT] !);\n  setPreviousOrParentTNode(viewHost !);\n  setIsParent(false);\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\n */\nexport function componentRefresh<T>(\n    adjustedElementIndex: number, parentFirstTemplatePass: boolean, rf: RenderFlags | null): void {\n  ngDevMode && assertDataInRange(adjustedElementIndex);\n  const hostView = getComponentViewByIndex(adjustedElementIndex, getViewData());\n  ngDevMode && assertNodeType(getTView().data[adjustedElementIndex] as TNode, TNodeType.Element);\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    parentFirstTemplatePass && syncViewWithBlueprint(hostView);\n    detectChangesInternal(hostView, hostView[CONTEXT], rf);\n  }\n}\n\n/**\n * Syncs an LViewData instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LViewData is created.\n * 3. Second <comp> is matched as a component and its LViewData is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LViewData was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param componentView The view to sync\n */\nfunction syncViewWithBlueprint(componentView: LViewData) {\n  const componentTView = componentView[TVIEW];\n  for (let i = componentView.length; i < componentTView.blueprint.length; i++) {\n    componentView[i] = componentTView.blueprint[i];\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nexport function viewAttached(view: LViewData): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const componentNode = findComponentView(getViewData())[HOST_NODE] as TElementNode;\n\n  if (!componentNode.projection) {\n    const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n    const pData: (TNode | null)[] = componentNode.projection =\n        new Array(noOfNodeBuckets).fill(null);\n    const tails: (TNode | null)[] = pData.slice();\n\n    let componentChild: TNode|null = componentNode.child;\n\n    while (componentChild !== null) {\n      const bucketIndex =\n          selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors !) : 0;\n      const nextNode = componentChild.next;\n\n      if (tails[bucketIndex]) {\n        tails[bucketIndex] !.next = componentChild;\n      } else {\n        pData[bucketIndex] = componentChild;\n        componentChild.next = null;\n      }\n      tails[bucketIndex] = componentChild;\n\n      componentChild = nextNode;\n    }\n  }\n}\n\n/**\n * Stack used to keep track of projection nodes in projection() instruction.\n *\n * This is deliberately created outside of projection() to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LViewData | TNode)[] = [];\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(nodeIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const viewData = getViewData();\n  const tProjectionNode =\n      createNodeAtIndex(nodeIndex, TNodeType.Projection, null, null, attrs || null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  setIsParent(false);\n\n  // re-distribution of projectable nodes is stored on a component's view level\n  const componentView = findComponentView(viewData);\n  const componentNode = componentView[HOST_NODE] as TElementNode;\n  let nodeToProject = (componentNode.projection as(TNode | null)[])[selectorIndex];\n  let projectedView = componentView[PARENT] !;\n  let projectionNodeIndex = -1;\n\n  while (nodeToProject) {\n    if (nodeToProject.type === TNodeType.Projection) {\n      // This node is re-projected, so we must go up the tree to get its projected nodes.\n      const currentComponentView = findComponentView(projectedView);\n      const currentComponentHost = currentComponentView[HOST_NODE] as TElementNode;\n      const firstProjectedNode =\n          (currentComponentHost.projection as(TNode | null)[])[nodeToProject.projection as number];\n\n      if (firstProjectedNode) {\n        projectionNodeStack[++projectionNodeIndex] = nodeToProject;\n        projectionNodeStack[++projectionNodeIndex] = projectedView;\n\n        nodeToProject = firstProjectedNode;\n        projectedView = currentComponentView[PARENT] !;\n        continue;\n      }\n    } else {\n      // This flag must be set now or we won't know that this node is projected\n      // if the nodes are inserted into a container later.\n      nodeToProject.flags |= TNodeFlags.isProjected;\n      appendProjectedNode(nodeToProject, tProjectionNode, viewData, projectedView);\n    }\n\n    // If we are finished with a list of re-projected nodes, we need to get\n    // back to the root projection node that was re-projected.\n    if (nodeToProject.next === null && projectedView !== componentView[PARENT] !) {\n      projectedView = projectionNodeStack[projectionNodeIndex--] as LViewData;\n      nodeToProject = projectionNodeStack[projectionNodeIndex--] as TNode;\n    }\n    nodeToProject = nodeToProject.next;\n  }\n}\n\n/**\n * Adds LViewData or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param currentView The view where LViewData or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\n * @param state The LViewData or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LViewData|LContainer>(\n    currentView: LViewData, adjustedHostIndex: number, state: T): T {\n  const tView = getTView();\n  const firstTemplatePass = getFirstTemplatePass();\n  if (currentView[TAIL]) {\n    currentView[TAIL] ![NEXT] = state;\n  } else if (firstTemplatePass) {\n    tView.childIndex = adjustedHostIndex;\n  }\n  currentView[TAIL] = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LViewData dirty. */\nfunction markDirtyIfOnPush(viewData: LViewData, viewIndex: number): void {\n  const view = getComponentViewByIndex(viewIndex, viewData);\n  if (!(view[FLAGS] & LViewFlags.CheckAlways)) {\n    view[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\n/** Wraps an event listener with preventDefault behavior. */\nfunction wrapListenerWithPreventDefault(listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_preventDefault(e: Event) {\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(view: LViewData): void {\n  let currentView: LViewData = view;\n\n  while (currentView && !(currentView[FLAGS] & LViewFlags.IsRoot)) {\n    currentView[FLAGS] |= LViewFlags.Dirty;\n    currentView = currentView[PARENT] !;\n  }\n  currentView[FLAGS] |= LViewFlags.Dirty;\n  ngDevMode && assertDefined(currentView[CONTEXT], 'rootContext should be defined');\n\n  const rootContext = currentView[CONTEXT] as RootContext;\n  scheduleTick(rootContext, RootContextFlags.DetectChanges);\n}\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  rootContext.flags |= flags;\n\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res !(null);\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n\nfunction tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    renderComponentOrTemplate(\n        readPatchedLViewData(rootComponent) !, rootComponent, RenderFlags.Update);\n  }\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  detectChangesInternal(getComponentViewByInstance(component) !, component, null);\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lViewData The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lViewData: LViewData): void {\n  tickRootContext(lViewData[CONTEXT] as RootContext);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChanges(component);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lViewData The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lViewData: LViewData): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lViewData);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nfunction detectChangesInternal<T>(hostView: LViewData, component: T, rf: RenderFlags | null) {\n  const hostTView = hostView[TVIEW];\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  const templateFn = hostTView.template !;\n  const viewQuery = hostTView.viewQuery;\n\n  try {\n    namespaceHTML();\n    createViewQuery(viewQuery, rf, hostView[FLAGS], component);\n    templateFn(rf || getRenderFlags(hostView), component);\n    refreshDescendantViews(hostView, rf);\n    updateViewQuery(viewQuery, hostView[FLAGS], component);\n  } finally {\n    leaveView(oldView, rf === RenderFlags.Create);\n  }\n}\n\nfunction createViewQuery<T>(\n    viewQuery: ComponentQuery<{}>| null, renderFlags: RenderFlags | null, viewFlags: LViewFlags,\n    component: T): void {\n  if (viewQuery && (renderFlags === RenderFlags.Create ||\n                    (renderFlags === null && (viewFlags & LViewFlags.CreationMode)))) {\n    viewQuery(RenderFlags.Create, component);\n  }\n}\n\nfunction updateViewQuery<T>(\n    viewQuery: ComponentQuery<{}>| null, flags: LViewFlags, component: T): void {\n  if (viewQuery && flags & RenderFlags.Update) {\n    viewQuery(RenderFlags.Update, component);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  markViewDirty(getComponentViewByInstance(component));\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T): T|NO_CHANGE {\n  return bindingUpdated(getViewData()[BINDING_INDEX]++, value) ? value : NO_CHANGE;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let different = false;\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(getViewData()[BINDING_INDEX]++, values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated(getViewData()[BINDING_INDEX]++, v0);\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const viewData = getViewData();\n  const different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\n  viewData[BINDING_INDEX] += 2;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  const viewData = getViewData();\n  const different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\n  viewData[BINDING_INDEX] += 3;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const viewData = getViewData();\n  const different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  viewData[BINDING_INDEX] += 4;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\n  viewData[BINDING_INDEX] += 5;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\n  viewData[BINDING_INDEX] += 6;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\n  viewData[BINDING_INDEX] += 7;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  const viewData = getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\n  viewData[BINDING_INDEX] += 8;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  const tView = getTView();\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n  }\n  getViewData()[adjustedIndex] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n */\nexport function reference<T>(index: number) {\n  const contextViewData = getContextViewData();\n  return loadInternal<T>(index, contextViewData);\n}\n\nexport function loadQueryList<T>(queryListIdx: number): QueryList<T> {\n  const viewData = getViewData();\n  ngDevMode && assertDefined(\n                   viewData[CONTENT_QUERIES],\n                   'Content QueryList array should be defined if reading a query.');\n  ngDevMode && assertDataInRange(queryListIdx, viewData[CONTENT_QUERIES] !);\n\n  return viewData[CONTENT_QUERIES] ![queryListIdx];\n}\n\n/** Retrieves a value from current `viewData`. */\nexport function load<T>(index: number): T {\n  return loadInternal<T>(index, getViewData());\n}\n\n/** Gets the current binding value. */\nexport function getBinding(bindingIndex: number): any {\n  const viewData = getViewData();\n  ngDevMode && assertDataInRange(viewData[bindingIndex]);\n  ngDevMode &&\n      assertNotEqual(viewData[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return viewData[bindingIndex];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(bindingIndex: number, value: any): boolean {\n  const viewData = getViewData();\n  const checkNoChangesMode = getCheckNoChangesMode();\n  ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && assertLessThan(\n                   bindingIndex, viewData.length, `Slot should have been initialized to NO_CHANGE`);\n\n  if (viewData[bindingIndex] === NO_CHANGE) {\n    viewData[bindingIndex] = value;\n  } else if (isDifferent(viewData[bindingIndex], value, checkNoChangesMode)) {\n    throwErrorIfNoChangesMode(getCreationMode(), checkNoChangesMode, viewData[bindingIndex], value);\n    viewData[bindingIndex] = value;\n  } else {\n    return false;\n  }\n  return true;\n}\n\n/** Updates binding and returns the value. */\nexport function updateBinding(bindingIndex: number, value: any): any {\n  return getViewData()[bindingIndex] = value;\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(bindingIndex: number, exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(bindingIndex, exp1);\n  return bindingUpdated(bindingIndex + 1, exp2) || different;\n}\n\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated3(bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean {\n  const different = bindingUpdated2(bindingIndex, exp1, exp2);\n  return bindingUpdated(bindingIndex + 2, exp3) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(\n    bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(bindingIndex, exp1, exp2);\n  return bindingUpdated2(bindingIndex + 2, exp3, exp4) || different;\n}\n\n\n///////////////////////////////\n//// DI\n///////////////////////////////\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags): T;\nexport function directiveInject<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  return getOrCreateInjectable<T>(\n      getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode,\n      getViewData(), token, flags);\n}\n\n/**\n * Facade for the attribute injection from DI.\n */\nexport function injectAttribute(attrNameToInject: string): string|undefined {\n  return injectAttributeImpl(getPreviousOrParentTNode(), attrNameToInject);\n}\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport function registerContentQuery<Q>(\n    queryList: QueryList<Q>, currentDirectiveIndex: number): void {\n  const viewData = getViewData();\n  const tView = getTView();\n  const savedContentQueriesLength =\n      (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\n  if (getFirstTemplatePass()) {\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex =\n        tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\n    if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\n      tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nfunction initializeTNodeInputs(tNode: TNode | null) {\n  // If tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked.\n  if (tNode) {\n    if (tNode.inputs === undefined) {\n      // mark inputs as checked\n      tNode.inputs = generatePropertyAliases(tNode.flags, BindingDirection.Input);\n    }\n    return tNode.inputs;\n  }\n  return null;\n}\n\nexport function delegateToClassInput(tNode: TNode) {\n  return tNode.flags & TNodeFlags.hasClassInput;\n}\n"]}