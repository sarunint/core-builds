{"version":3,"file":"context_discovery.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/context_discovery.ts"],"names":[],"mappings":";;;;AAOA,OAAO,eAAe,CAAC;AAEvB,OAAO,EAAC,WAAW,EAAC,MAAM,UAAU,CAAC;AACrC,OAAO,EAAW,qBAAqB,EAAC,MAAM,sBAAsB,CAAC;AAGrE,OAAO,EAAC,OAAO,EAAE,aAAa,EAAE,IAAI,EAAa,KAAK,EAAC,MAAM,mBAAmB,CAAC;AACjF,OAAO,EAAC,uBAAuB,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,eAAe,EAAC,MAAM,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;AAoBpG,MAAM,UAAU,UAAU,CAAC,MAAW;;IACpC,IAAI,OAAO,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;IACtC,IAAI,OAAO,EAAE;;;QAGX,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;;YAC1B,MAAM,SAAS,sBAAc,OAAO,GAAG;;YACvC,IAAI,SAAS,CAAS;;YACtB,IAAI,SAAS,GAAQ,SAAS,CAAC;;YAC/B,IAAI,UAAU,GAAyB,SAAS,CAAC;YAEjD,IAAI,mBAAmB,CAAC,MAAM,CAAC,EAAE;gBAC/B,SAAS,GAAG,gBAAgB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;gBAChD,IAAI,SAAS,IAAI,CAAC,CAAC,EAAE;oBACnB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;iBAC5E;gBACD,SAAS,GAAG,MAAM,CAAC;aACpB;iBAAM,IAAI,mBAAmB,CAAC,MAAM,CAAC,EAAE;gBACtC,SAAS,GAAG,gBAAgB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;gBAChD,IAAI,SAAS,IAAI,CAAC,CAAC,EAAE;oBACnB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;iBAC5E;gBACD,UAAU,GAAG,kBAAkB,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;aAC9D;iBAAM;gBACL,SAAS,GAAG,oBAAoB,CAAC,SAAS,oBAAE,MAAkB,EAAC,CAAC;gBAChE,IAAI,SAAS,IAAI,CAAC,CAAC,EAAE;oBACnB,OAAO,IAAI,CAAC;iBACb;aACF;;YAMD,MAAM,MAAM,GAAG,gBAAgB,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;;YACtD,MAAM,WAAW,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;;YAC5C,MAAM,OAAO,GAAa,CAAC,WAAW,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBACpE,WAAW,CAAC,CAAC;gBACb,cAAc,CAAC,SAAS,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;;YAGjD,IAAI,SAAS,IAAI,OAAO,CAAC,SAAS,KAAK,SAAS,EAAE;gBAChD,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;gBAC9B,eAAe,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;aAC7C;;YAGD,IAAI,UAAU,IAAI,OAAO,CAAC,UAAU,KAAK,SAAS,EAAE;gBAClD,OAAO,CAAC,UAAU,GAAG,UAAU,CAAC;gBAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC1C,eAAe,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;iBACzC;aACF;YAED,eAAe,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YACzC,OAAO,GAAG,OAAO,CAAC;SACnB;KACF;SAAM;;QACL,MAAM,QAAQ,qBAAG,MAAkB,EAAC;QACpC,SAAS,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC;;QAIxC,IAAI,MAAM,qBAAG,QAAe,EAAC;QAC7B,OAAO,MAAM,GAAG,MAAM,CAAC,UAAU,EAAE;;YACjC,MAAM,aAAa,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;YAC9C,IAAI,aAAa,EAAE;;gBACjB,IAAI,SAAS,CAAiB;gBAC9B,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;oBAChC,SAAS,qBAAG,aAA0B,CAAA,CAAC;iBACxC;qBAAM;oBACL,SAAS,GAAG,aAAa,CAAC,SAAS,CAAC;iBACrC;;;gBAID,IAAI,CAAC,SAAS,EAAE;oBACd,OAAO,IAAI,CAAC;iBACb;;gBAED,MAAM,KAAK,GAAG,oBAAoB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;gBACxD,IAAI,KAAK,IAAI,CAAC,EAAE;;oBACd,MAAM,MAAM,GAAG,gBAAgB,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;;oBAClD,MAAM,OAAO,GAAG,cAAc,CAAC,SAAS,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;oBACzD,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;oBACjC,OAAO,GAAG,OAAO,CAAC;oBAClB,MAAM;iBACP;aACF;SACF;KACF;IACD,OAAO,mBAAC,OAAmB,EAAC,IAAI,IAAI,CAAC;CACtC;;;;;;;;AAKD,SAAS,cAAc,CAAC,SAAoB,EAAE,SAAiB,EAAE,MAAgB;IAC/E,OAAO;QACL,SAAS;QACT,SAAS,EAAE,SAAS,EAAE,MAAM;QAC5B,SAAS,EAAE,SAAS;QACpB,UAAU,EAAE,SAAS;QACrB,SAAS,EAAE,SAAS;KACrB,CAAC;CACH;;;;;;;AAQD,MAAM,UAAU,0BAA0B,CAAC,iBAAqB;;IAC9D,IAAI,SAAS,GAAG,eAAe,CAAC,iBAAiB,CAAC,CAAC;;IACnD,IAAI,IAAI,CAAY;IAEpB,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;;QAC5B,MAAM,SAAS,GAAG,gBAAgB,CAAC,SAAS,EAAE,iBAAiB,CAAC,CAAC;QACjE,IAAI,GAAG,uBAAuB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;;QACrD,MAAM,OAAO,GAAG,cAAc,CAAC,SAAS,EAAE,SAAS,oBAAE,IAAI,CAAC,IAAI,CAAa,EAAC,CAAC;QAC7E,OAAO,CAAC,SAAS,GAAG,iBAAiB,CAAC;QACtC,eAAe,CAAC,iBAAiB,EAAE,OAAO,CAAC,CAAC;QAC5C,eAAe,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;KAC1C;SAAM;;QACL,MAAM,OAAO,sBAAG,SAAgB,GAAa;QAC7C,IAAI,GAAG,uBAAuB,CAAC,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;KACtE;IACD,OAAO,IAAI,CAAC;CACb;;;;;;;;AAMD,MAAM,UAAU,eAAe,CAAC,MAAW,EAAE,IAA0B;IACrE,MAAM,CAAC,qBAAqB,CAAC,GAAG,IAAI,CAAC;CACtC;;;;;AAED,MAAM,UAAU,mBAAmB,CAAC,QAAa;IAC/C,OAAO,QAAQ,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,WAAW,CAAC,cAAc,CAAC;CAChF;;;;;AAED,MAAM,UAAU,mBAAmB,CAAC,QAAa;IAC/C,OAAO,QAAQ,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,WAAW,CAAC,cAAc,CAAC;CAChF;;;;;;;AAKD,SAAS,oBAAoB,CAAC,SAAoB,EAAE,MAAgB;;IAClE,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC;IACxC,OAAO,KAAK,EAAE;;QACZ,MAAM,MAAM,sBAAG,gBAAgB,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG;QACpD,IAAI,MAAM,KAAK,MAAM,EAAE;YACrB,OAAO,KAAK,CAAC,KAAK,CAAC;SACpB;QACD,KAAK,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC;KACpC;IAED,OAAO,CAAC,CAAC,CAAC;CACX;;;;;;AAKD,SAAS,mBAAmB,CAAC,KAAY;IACvC,IAAI,KAAK,CAAC,KAAK,EAAE;QACf,OAAO,KAAK,CAAC,KAAK,CAAC;KACpB;SAAM,IAAI,KAAK,CAAC,IAAI,EAAE;QACrB,OAAO,KAAK,CAAC,IAAI,CAAC;KACnB;SAAM,IAAI,KAAK,CAAC,MAAM,EAAE;QACvB,OAAO,KAAK,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC;KAClC;IACD,OAAO,IAAI,CAAC;CACb;;;;;;;AAKD,SAAS,gBAAgB,CAAC,SAAoB,EAAE,iBAAqB;;IACnE,MAAM,gBAAgB,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC;IACrD,IAAI,gBAAgB,EAAE;QACpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;YAChD,MAAM,qBAAqB,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;;YAClD,MAAM,aAAa,GAAG,uBAAuB,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC;YAChF,IAAI,aAAa,CAAC,OAAO,CAAC,KAAK,iBAAiB,EAAE;gBAChD,OAAO,qBAAqB,CAAC;aAC9B;SACF;KACF;SAAM;;QACL,MAAM,iBAAiB,GAAG,uBAAuB,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;;QAC5E,MAAM,aAAa,GAAG,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACjD,IAAI,aAAa,KAAK,iBAAiB,EAAE;;;YAGvC,OAAO,aAAa,CAAC;SACtB;KACF;IACD,OAAO,CAAC,CAAC,CAAC;CACX;;;;;;;AAKD,SAAS,gBAAgB,CAAC,SAAoB,EAAE,iBAAqB;;IAMnE,IAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC;IACxC,OAAO,KAAK,EAAE;;QACZ,MAAM,mBAAmB,GAAG,sBAAsB,CAAC,KAAK,CAAC,CAAC;;QAC1D,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;QAC3E,KAAK,IAAI,CAAC,GAAG,mBAAmB,EAAE,CAAC,GAAG,iBAAiB,EAAE,CAAC,EAAE,EAAE;YAC5D,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,iBAAiB,EAAE;gBACtC,OAAO,KAAK,CAAC,KAAK,CAAC;aACpB;SACF;QACD,KAAK,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC;KACpC;IACD,OAAO,CAAC,CAAC,CAAC;CACX;;;;;AAED,SAAS,gBAAgB,CAAC,OAAY;IACpC,WAAW,CACP,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,YAAY,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EACxF,IAAI,EAAE,0DAA0D,CAAC,CAAC;CACvE;;;;;;;;;;AAUD,MAAM,UAAU,kBAAkB,CAC9B,SAAiB,EAAE,SAAoB,EAAE,iBAA0B;;IACrE,MAAM,KAAK,qBAAG,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS,CAAU,EAAC;;IACxD,IAAI,mBAAmB,GAAG,sBAAsB,CAAC,KAAK,CAAC,CAAC;;IACxD,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;IAC3E,IAAI,CAAC,iBAAiB,IAAI,KAAK,CAAC,KAAK,yBAAyB;QAAE,mBAAmB,EAAE,CAAC;IACtF,OAAO,SAAS,CAAC,KAAK,CAAC,mBAAmB,EAAE,iBAAiB,CAAC,CAAC;CAChE;;;;;;;;AAMD,MAAM,UAAU,iBAAiB,CAAC,SAAoB,EAAE,SAAiB;;IAEvE,MAAM,KAAK,qBAAG,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS,CAAU,EAAC;IACxD,IAAI,KAAK,IAAI,KAAK,CAAC,UAAU,EAAE;;QAC7B,MAAM,MAAM,GAAyB,EAAE,CAAC;QACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;;YACnD,MAAM,YAAY,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;;YACzC,MAAM,cAAc,qBAAG,KAAK,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAW,EAAC;YACzD,MAAM,CAAC,YAAY,CAAC;gBAChB,cAAc,KAAK,CAAC,CAAC,CAAC,CAAC,oBAAC,gBAAgB,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;SAC9F;QACD,OAAO,MAAM,CAAC;KACf;IAED,OAAO,IAAI,CAAC;CACb;;;;;AAED,SAAS,sBAAsB,CAAC,KAAY;;;;IAI1C,OAAO,KAAK,CAAC,KAAK,wCAA0C,CAAC;CAC9D;;;;;;AAED,SAAS,oBAAoB,CAAC,KAAY,EAAE,UAAkB;;IAI5D,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,gCAAgC,CAAC;IAC1D,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;CAC1C","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport './ng_dev_mode';\n\nimport {assertEqual} from './assert';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, HOST, LViewData, TVIEW} from './interfaces/view';\nimport {getComponentViewByIndex, getNativeByTNode, readElementValue, readPatchedData} from './util';\n\n\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LViewData` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n */\nexport function getContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LViewData instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lViewData: LViewData = mpValue !;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lViewData, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lViewData, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = discoverDirectives(nodeIndex, lViewData, false);\n      } else {\n        nodeIndex = findViaNativeElement(lViewData, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, compontent or\n      // directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = readElementValue(lViewData[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lViewData, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomElement(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lViewData: LViewData|null;\n        if (Array.isArray(parentContext)) {\n          lViewData = parentContext as LViewData;\n        } else {\n          lViewData = parentContext.lViewData;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lViewData) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lViewData, rElement);\n        if (index >= 0) {\n          const native = readElementValue(lViewData[index]);\n          const context = createLContext(lViewData, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lViewData: LViewData, nodeIndex: number, native: RElement): LContext {\n  return {\n    lViewData,\n    nodeIndex: nodeIndex, native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LViewData {\n  let lViewData = readPatchedData(componentInstance);\n  let view: LViewData;\n\n  if (Array.isArray(lViewData)) {\n    const nodeIndex = findViaComponent(lViewData, componentInstance);\n    view = getComponentViewByIndex(nodeIndex, lViewData);\n    const context = createLContext(lViewData, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lViewData as any as LContext;\n    view = getComponentViewByIndex(context.nodeIndex, context.lViewData);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LViewData | LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngComponentDef;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ngDirectiveDef;\n}\n\n/**\n * Locates the element within the given LViewData and returns the matching index\n */\nfunction findViaNativeElement(lViewData: LViewData, target: RElement): number {\n  let tNode = lViewData[TVIEW].firstChild;\n  while (tNode) {\n    const native = getNativeByTNode(tNode, lViewData) !;\n    if (native === target) {\n      return tNode.index;\n    }\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else if (tNode.parent) {\n    return tNode.parent.next || null;\n  }\n  return null;\n}\n\n/**\n * Locates the component within the given LViewData and returns the matching index\n */\nfunction findViaComponent(lViewData: LViewData, componentInstance: {}): number {\n  const componentIndices = lViewData[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentViewByIndex(elementComponentIndex, lViewData);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lViewData);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LViewData and returns the matching index\n */\nfunction findViaDirective(lViewData: LViewData, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LViewData of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lViewData[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = getDirectiveStartIndex(tNode);\n    const directiveIndexEnd = getDirectiveEndIndex(tNode, directiveIndexStart);\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lViewData[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\nfunction assertDomElement(element: any) {\n  assertEqual(\n      element && (element.nodeType == Node.ELEMENT_NODE || element.nodeType == Node.TEXT_NODE),\n      true, 'The provided value must be an instance of an HTMLElement');\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lViewData The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function discoverDirectives(\n    nodeIndex: number, lViewData: LViewData, includeComponents: boolean): any[]|null {\n  const tNode = lViewData[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = getDirectiveStartIndex(tNode);\n  const directiveEndIndex = getDirectiveEndIndex(tNode, directiveStartIndex);\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponent) directiveStartIndex++;\n  return lViewData.slice(directiveStartIndex, directiveEndIndex);\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lViewData: LViewData, nodeIndex: number): {[key: string]: any}|\n    null {\n  const tNode = lViewData[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      const localRefName = tNode.localNames[i];\n      const directiveIndex = tNode.localNames[i + 1] as number;\n      result[localRefName] =\n          directiveIndex === -1 ? getNativeByTNode(tNode, lViewData) ! : lViewData[directiveIndex];\n    }\n    return result;\n  }\n\n  return null;\n}\n\nfunction getDirectiveStartIndex(tNode: TNode): number {\n  // the tNode instances store a flag value which then has a\n  // pointer which tells the starting index of where all the\n  // active directives are in the master directive array\n  return tNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n}\n\nfunction getDirectiveEndIndex(tNode: TNode, startIndex: number): number {\n  // The end value is also a part of the same flag\n  // (see `TNodeFlags` to see how the flag bit shifting\n  // values are used).\n  const count = tNode.flags & TNodeFlags.DirectiveCountMask;\n  return count ? (startIndex + count) : -1;\n}\n"]}